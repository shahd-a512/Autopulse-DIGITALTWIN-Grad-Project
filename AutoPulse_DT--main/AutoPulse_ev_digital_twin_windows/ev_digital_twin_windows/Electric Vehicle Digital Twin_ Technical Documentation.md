# Electric Vehicle Digital Twin: Technical Documentation

## Table of Contents

1. [Introduction](#introduction)
2. [System Architecture](#system-architecture)
3. [Mathematical Models](#mathematical-models)
   - [Battery Model](#battery-model)
   - [Motor Model](#motor-model)
   - [Vehicle Physics Model](#vehicle-physics-model)
4. [Data Flow Architecture](#data-flow-architecture)
5. [Implementation Details](#implementation-details)
6. [Simulation Process](#simulation-process)
7. [References](#references)

## Introduction

The Electric Vehicle Digital Twin is a comprehensive simulation model that replicates the behavior of an electric vehicle and its key components. This digital twin integrates detailed models of the battery, electric motor, and vehicle physics to provide accurate predictions of vehicle performance, energy consumption, and range.

This technical documentation covers all aspects of the Electric Vehicle Digital Twin, including the mathematical models, physical principles, implementation details, and data flow architecture. It serves as a reference for understanding the concepts and calculations used in the simulation.

## System Architecture

The Electric Vehicle Digital Twin is structured as a hierarchical system with three main components:

1. **Battery Model** (`SimplifiedBatteryModel`): Simulates the battery behavior, tracking state of charge, voltage, current, and temperature.
2. **Motor Model** (`SimplifiedPMSMMotorModel`): Simulates the electric motor behavior, calculating torque, speed, currents, voltages, and efficiency.
3. **Vehicle Physics Model** (part of `ElectricVehicleDigitalTwin`): Simulates the vehicle dynamics, including resistive forces, acceleration, and energy consumption.

These components are integrated in the `ElectricVehicleDigitalTwin` class, which coordinates the data flow between them and provides a unified interface for simulation.

The system architecture is designed to be modular, allowing each component to be developed, tested, and refined independently while maintaining clear interfaces for integration.

## Mathematical Models

### Battery Model

The battery model (`SimplifiedBatteryModel`) implements several key mathematical calculations to simulate the behavior of a lithium-ion battery pack.

#### State of Charge (SOC) Calculation

The State of Charge (SOC) is calculated using coulomb counting, which integrates the current over time:

$$\frac{dSOC}{dt} = -\frac{I}{C_{nominal} \times 3600}$$

Where:
- $\frac{dSOC}{dt}$ is the rate of change of the state of charge (dimensionless, range 0-1)
- $I$ is the current in Amperes (positive for discharge, negative for charge)
- $C_{nominal}$ is the battery capacity in Ampere-hours (Ah)
- $3600$ converts hours to seconds (since capacity is in Ah but time is in seconds)

This differential equation is solved using numerical integration methods (specifically the RK45 method - Runge-Kutta 4th/5th order) provided by SciPy's `solve_ivp` function.

#### Voltage Calculation

The battery voltage is calculated based on the state of charge using a piecewise function that captures the nonlinear relationship between SOC and voltage:

For SOC ≥ 0.9 (high SOC region):
$$V = V_{full} - (V_{full} - V_{nominal}) \times e^{-10 \times (SOC - 0.9)}$$

For SOC ≤ 0.1 (low SOC region):
$$V = V_{empty} + (V_{nominal} - V_{empty}) \times e^{10 \times SOC}$$

For 0.1 < SOC < 0.9 (middle region):
$$V = V_{nominal} + (SOC - 0.5) \times k_{voltage}$$

Where:
- $V$ is the battery terminal voltage in Volts
- $V_{full}$ is the voltage at full charge (nominal voltage + 0.5V)
- $V_{empty}$ is the voltage at empty (nominal voltage - 0.7V)
- $V_{nominal}$ is the nominal battery voltage
- $k_{voltage}$ is the voltage vs SOC curve steepness (0.1)
- $SOC$ is the state of charge (0 to 1)

This model captures the characteristic behavior of lithium-ion batteries:
- Exponential voltage rise as the battery approaches full charge
- Relatively flat voltage in the middle SOC range
- Exponential voltage drop as the battery approaches depletion

#### Temperature Dynamics

The battery temperature is modeled using a thermal equation:

$$\frac{dT}{dt} = \frac{Q_{gen} - Q_{cool}}{C_{thermal}}$$

Where:
- $\frac{dT}{dt}$ is the rate of change of temperature in Kelvin per second
- $Q_{gen} = I^2 \times R_{internal}$ is the heat generated by Joule heating in Watts
- $Q_{cool} = h \times (T - T_{ambient})$ is the heat dissipated by cooling in Watts
- $C_{thermal}$ is the thermal mass of the battery in Joules per Kelvin
- $I$ is the current in Amperes
- $R_{internal}$ is the internal resistance in Ohms
- $h$ is the cooling coefficient in Watts per Kelvin
- $T$ is the battery temperature in Kelvin
- $T_{ambient}$ is the ambient temperature in Kelvin

This temperature model is based on the principles of thermal energy balance:
- Joule heating (I²R losses) generates heat proportional to the square of the current
- Newton's law of cooling states that the rate of heat loss is proportional to the temperature difference between the object and its surroundings

#### Power and Current Relationship

When a power demand is applied to the battery, the current is calculated as:

$$I = \frac{P}{V}$$

Where:
- $I$ is the current in Amperes
- $P$ is the power in Watts
- $V$ is the battery voltage in Volts

This relationship is derived from the basic electrical power equation: P = V × I. In an electric vehicle, the power demand is determined by the vehicle's speed, acceleration, and resistive forces. The battery must supply this power, and the current drawn depends on the battery's voltage.

#### Battery Cell Configuration

The battery model represents a complete battery pack, which consists of multiple cells connected in series and parallel. The relationship between cell-level and pack-level parameters is as follows:

For cells in series:
$$V_{pack} = n_{series} \times V_{cell}$$

For cells in parallel:
$$C_{pack} = n_{parallel} \times C_{cell}$$

Where:
- $V_{pack}$ is the pack voltage
- $V_{cell}$ is the individual cell voltage
- $n_{series}$ is the number of cells in series
- $C_{pack}$ is the pack capacity in Ah
- $C_{cell}$ is the individual cell capacity in Ah
- $n_{parallel}$ is the number of cells in parallel

### Motor Model

The motor model (`SimplifiedPMSMMotorModel`) implements mathematical calculations for a Permanent Magnet Synchronous Motor (PMSM) used in electric vehicles.

#### Electromagnetic Torque

The electromagnetic torque in a PMSM is calculated using the d-q axis model:

$$T_{em} = \frac{3}{2} \times p \times [(L_d - L_q) \times i_d \times i_q + \psi_{pm} \times i_q]$$

Where:
- $T_{em}$ is the electromagnetic torque in Newton-meters (Nm)
- $p$ is the number of pole pairs
- $L_d$ is the d-axis inductance in Henries (H)
- $L_q$ is the q-axis inductance in Henries (H)
- $i_d$ is the d-axis current in Amperes (A)
- $i_q$ is the q-axis current in Amperes (A)
- $\psi_{pm}$ is the permanent magnet flux linkage in Webers (Wb)

This equation represents the torque production in a PMSM, which consists of two components:
1. **Reluctance torque**: $(L_d - L_q) \times i_d \times i_q$ - caused by the difference in magnetic reluctance between the d and q axes
2. **Magnetic torque**: $\psi_{pm} \times i_q$ - caused by the interaction between the permanent magnet field and the q-axis current

#### Motor Speed Dynamics

The motor speed dynamics are governed by Newton's second law for rotational motion:

$$\frac{d\omega}{dt} = \frac{T_{em} - T_{load} - B\omega}{J}$$

Where:
- $\frac{d\omega}{dt}$ is the angular acceleration in radians per second squared (rad/s²)
- $\omega$ is the angular velocity in radians per second (rad/s)
- $T_{em}$ is the electromagnetic torque in Newton-meters (Nm)
- $T_{load}$ is the load torque in Newton-meters (Nm)
- $B$ is the viscous friction coefficient in Newton-meter-seconds per radian (Nm·s/rad)
- $J$ is the moment of inertia of the rotor in kilogram-meter-squared (kg·m²)

This equation represents the rotational form of Newton's second law (F = ma), where the net torque causes angular acceleration.

#### Current Dynamics and Field-Oriented Control

The current dynamics in the motor are modeled with simplified field-oriented control (FOC):

$$\frac{di_d}{dt} = \frac{i_{d,ref} - i_d}{\tau_i}$$

$$\frac{di_q}{dt} = \frac{i_{q,ref} - i_q}{\tau_i}$$

Where:
- $\frac{di_d}{dt}$ and $\frac{di_q}{dt}$ are the rates of change of the d-axis and q-axis currents
- $i_{d,ref}$ and $i_{q,ref}$ are the reference (target) currents
- $i_d$ and $i_q$ are the actual currents
- $\tau_i$ is the current control time constant in seconds

The reference currents are determined based on the torque control strategy:

For normal operation (below nominal speed):
- $i_{d,ref} = 0$ (zero d-axis current for maximum torque per ampere)
- $i_{q,ref} = \frac{2 \times T_{load}}{3 \times p \times \psi_{pm}}$ (q-axis current to produce the required torque)

For field weakening (above nominal speed):
- $i_{d,ref} = -0.2 \times I_{max} \times \frac{|\omega| - \omega_{nominal}}{\omega_{nominal}}$ (negative d-axis current to reduce field)
- $i_{q,ref}$ calculated as above

Field-oriented control (FOC) allows independent control of torque and flux, maximum torque per ampere (MTPA) operation, and field weakening operation at high speeds.

#### Voltage Calculation

The d-q voltages in a PMSM are calculated using the voltage equations:

$$v_d = R_s \times i_d - \omega \times L_q \times i_q$$

$$v_q = R_s \times i_q + \omega \times L_d \times i_d + \omega \times \psi_{pm}$$

Where:
- $v_d$ and $v_q$ are the d-axis and q-axis voltages in Volts (V)
- $R_s$ is the stator resistance in Ohms (Ω)
- $\omega$ is the electrical angular velocity in radians per second (rad/s)
- $L_d$ and $L_q$ are the d-axis and q-axis inductances in Henries (H)
- $i_d$ and $i_q$ are the d-axis and q-axis currents in Amperes (A)
- $\psi_{pm}$ is the permanent magnet flux linkage in Webers (Wb)

These equations describe the voltage-current relationship in a PMSM in the d-q reference frame.

#### Coordinate Transformations

The Park transformation converts between d-q and three-phase (abc) coordinates:

$$i_a = i_d \times \cos(\theta) - i_q \times \sin(\theta)$$

$$i_b = i_d \times \cos(\theta - \frac{2\pi}{3}) - i_q \times \sin(\theta - \frac{2\pi}{3})$$

$$i_c = i_d \times \cos(\theta - \frac{4\pi}{3}) - i_q \times \sin(\theta - \frac{4\pi}{3})$$

Where:
- $i_a$, $i_b$, and $i_c$ are the three-phase currents in Amperes (A)
- $i_d$ and $i_q$ are the d-axis and q-axis currents in Amperes (A)
- $\theta$ is the electrical angle in radians

The Park transformation converts three-phase quantities in a stationary reference frame to a rotating reference frame aligned with the rotor flux, simplifying the control of AC machines.

#### Efficiency Calculation

The motor efficiency is calculated as the ratio of mechanical power to electrical power:

$$\eta = \frac{P_{mechanical}}{P_{electrical}} = \frac{|\omega \times T|}{|\omega \times T| + P_{losses}}$$

Where:
- $\eta$ is the efficiency (0 to 1)
- $P_{mechanical} = |\omega \times T|$ is the mechanical power in Watts (W)
- $P_{electrical} = P_{mechanical} + P_{losses}$ is the electrical power in Watts (W)
- $P_{losses} = P_{copper} + P_{iron} + P_{friction}$ is the total power losses in Watts (W)
- $P_{copper} = R_s \times (i_d^2 + i_q^2)$ is the copper (resistive) losses in Watts (W)
- $P_{iron} = k_{iron} \times \omega^2$ is the iron (core) losses in Watts (W)
- $P_{friction} = B \times \omega^2$ is the friction losses in Watts (W)

The efficiency calculation accounts for various loss mechanisms in the motor and varies with operating conditions (speed, torque).

#### Motor Speed Control

The motor speed control is implemented using a PI (Proportional-Integral) controller:

$$T_{control} = K_p \times (ω_{ref} - ω) + K_i \times \int (ω_{ref} - ω) \, dt$$

Where:
- $T_{control}$ is the control torque in Newton-meters (Nm)
- $K_p$ is the proportional gain
- $K_i$ is the integral gain
- $ω_{ref}$ is the reference (target) speed in radians per second (rad/s)
- $ω$ is the actual speed in radians per second (rad/s)

This control strategy provides good speed tracking performance with zero steady-state error.

### Vehicle Physics Model

The vehicle physics model in `ElectricVehicleDigitalTwin` simulates the dynamic behavior of an electric vehicle.

#### Resistive Forces

The total resistive force acting on the vehicle is calculated as the sum of rolling resistance and aerodynamic drag:

$$F_{resistive} = F_{rolling} + F_{drag}$$

Where:
- $F_{rolling} = \mu_r \times m \times g$ is the rolling resistance force in Newtons (N)
- $F_{drag} = \frac{1}{2} \times \rho \times C_d \times A \times v^2$ is the aerodynamic drag force in Newtons (N)

With:
- $\mu_r$ is the rolling resistance coefficient (dimensionless)
- $m$ is the vehicle mass in kilograms (kg)
- $g$ is the gravitational acceleration (9.81 m/s²)
- $\rho$ is the air density (1.225 kg/m³ at sea level and 15°C)
- $C_d$ is the aerodynamic drag coefficient (dimensionless)
- $A$ is the frontal area of the vehicle in square meters (m²)
- $v$ is the vehicle speed in meters per second (m/s)

Rolling resistance is caused by the deformation of the tires as they roll on the road surface, while aerodynamic drag is caused by the vehicle pushing air out of its way as it moves. The drag force is proportional to the square of the vehicle speed, which means it becomes the dominant resistive force at higher speeds.

#### Acceleration Force

The force required to accelerate the vehicle is calculated using Newton's second law:

$$F_{acceleration} = m \times a$$

Where:
- $F_{acceleration}$ is the acceleration force in Newtons (N)
- $m$ is the vehicle mass in kilograms (kg)
- $a$ is the acceleration in meters per second squared (m/s²)

This equation directly applies Newton's second law of motion (F = ma).

#### Total Tractive Force

The total tractive force required at the wheels is the sum of the resistive and acceleration forces:

$$F_{total} = F_{resistive} + F_{acceleration}$$

This force must be provided by the motor through the drivetrain.

#### Power Demand

The power demand is calculated as the product of the total force and the vehicle speed:

$$P = F_{total} \times v$$

Where:
- $P$ is the power in Watts (W)
- $F_{total}$ is the total tractive force in Newtons (N)
- $v$ is the vehicle speed in meters per second (m/s)

This equation represents the mechanical power required to overcome all resistive forces and achieve the desired acceleration at the current speed.

#### Speed and Torque Conversions

The motor speed (in rpm) is related to the vehicle speed by:

$$\omega_{motor} = \frac{v \times 60 \times GR}{2\pi \times r_{wheel}}$$

Where:
- $\omega_{motor}$ is the motor speed in revolutions per minute (rpm)
- $v$ is the vehicle speed in meters per second (m/s)
- $GR$ is the gear ratio between the motor and wheels
- $r_{wheel}$ is the wheel radius in meters (m)
- The factor of 60 converts from revolutions per second to revolutions per minute

The tractive force at the wheels is related to the motor torque by:

$$F_{wheel} = \frac{T_{motor} \times GR}{r_{wheel}}$$

Where:
- $F_{wheel}$ is the tractive force at the wheels in Newtons (N)
- $T_{motor}$ is the motor torque in Newton-meters (Nm)
- $GR$ is the gear ratio between the motor and wheels
- $r_{wheel}$ is the wheel radius in meters (m)

These conversions represent the mechanical relationships in the drivetrain.

#### Vehicle State Update

The vehicle state is updated based on the current speed, acceleration, and time step:

$$d_{new} = d_{old} + v \times \Delta t$$

Where:
- $d_{new}$ is the updated distance in meters (m)
- $d_{old}$ is the previous distance in meters (m)
- $v$ is the vehicle speed in meters per second (m/s)
- $\Delta t$ is the time step in seconds (s)

This update follows the basic kinematic equation for distance traveled at a constant speed over a given time interval.

#### Energy Consumption and Range

The energy consumption is calculated by integrating the power demand over time:

$$E = \int P(t) \, dt \approx \sum_{i} P_i \times \Delta t$$

Where:
- $E$ is the energy consumed in kilowatt-hours (kWh)
- $P(t)$ is the power demand as a function of time in kilowatts (kW)
- $P_i$ is the power demand at time step $i$ in kilowatts (kW)
- $\Delta t$ is the time step in hours (h)

The vehicle range can be estimated based on the current state of charge and energy consumption rate:

$$Range = \frac{SOC \times E_{battery}}{E_{rate}}$$

Where:
- $Range$ is the estimated range in kilometers (km)
- $SOC$ is the current state of charge (0 to 1)
- $E_{battery}$ is the total battery energy capacity in kilowatt-hours (kWh)
- $E_{rate}$ is the energy consumption rate in kilowatt-hours per kilometer (kWh/km)

## Data Flow Architecture

The data flow in the Electric Vehicle Digital Twin follows a specific sequence during simulation, coordinating the interactions between the battery model, motor model, and vehicle physics components.

### Component Interaction Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                  Electric Vehicle Digital Twin                   │
│                                                                 │
│  ┌───────────────┐      ┌───────────────┐      ┌───────────────┐  │
│  │ Vehicle       │      │ Battery       │      │ Motor         │  │
│  │ Physics Model │◄────►│ Model         │◄────►│ Model         │  │
│  └───────────────┘      └───────────────┘      └───────────────┘  │
│          ▲                      ▲                      ▲          │
└──────────┼──────────────────────┼──────────────────────┼──────────┘
           │                      │                      │
           ▼                      ▼                      ▼
┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐
│ Speed Profile       │ │ Battery Parameters   │ │ Motor Parameters    │
│ - Target speed      │ │ - Capacity           │ │ - Nominal power     │
│ - Acceleration      │ │ - Voltage            │ │ - Nominal speed     │
└─────────────────────┘ └─────────────────────┘ └─────────────────────┘
```

### Data Flow Sequence

1. **Input**: The simulation receives a speed profile (target speed as a function of time)
2. **Vehicle Physics Calculation**:
   - Calculate acceleration from speed changes
   - Calculate resistive forces (rolling resistance, aerodynamic drag)
   - Calculate acceleration force
   - Calculate total tractive force
   - Calculate power demand

3. **Motor Model Interaction**:
   - Convert vehicle speed to motor speed (rpm)
   - Convert tractive force to motor torque
   - Apply torque to motor model
   - Receive motor efficiency, currents, voltages

4. **Battery Model Interaction**:
   - Convert power demand to battery current
   - Apply current to battery model
   - Receive battery state (SOC, voltage, temperature)

5. **State Update**:
   - Update vehicle state (speed, acceleration, distance)
   - Update battery state
   - Update motor state

6. **Output**: The simulation returns comprehensive results including:
   - Vehicle dynamics (speed, acceleration, distance)
   - Battery performance (SOC, voltage, current, temperature)
   - Motor performance (speed, torque, efficiency)
   - Energy consumption

### Key Data Exchanges

#### From Vehicle Physics to Motor Model

```
Vehicle Physics Model                 Motor Model
┌───────────────────┐                ┌───────────────────┐
│                   │                │                   │
│  Calculate        │                │                   │
│  tractive force   │─────────────►│  Apply torque     │
│                   │  Torque (Nm)   │  to motor        │
│                   │                │                   │
│  Calculate        │                │                   │
│  vehicle speed    │─────────────►│  Set motor speed  │
│                   │  Speed (rpm)   │                   │
│                   │                │                   │
│                   │◄───────────────│  Return motor     │
│                   │  Efficiency (%) │  efficiency       │
└───────────────────┘                └───────────────────┘
```

#### From Vehicle Physics to Battery Model

```
Vehicle Physics Model                 Battery Model
┌───────────────────┐                ┌───────────────────┐
│                   │                │                   │
│  Calculate        │                │                   │
│  power demand     │─────────────►│  Apply current    │
│                   │  Current (A)   │  to battery       │
│                   │                │                   │
│                   │◄───────────────│  Return battery   │
│                   │  Voltage (V)    │  voltage          │
│                   │                │                   │
│                   │◄───────────────│  Return battery   │
│                   │  SOC (0-1)      │  state of charge  │
└───────────────────┘                └───────────────────┘
```

### Feedback Loops

- **Battery Voltage to Power Calculation**: The battery voltage affects the current required for a given power demand
- **Motor Efficiency to Power Demand**: The motor efficiency affects the electrical power required for a given mechanical power
- **Battery SOC to Vehicle Range**: The battery SOC determines the remaining range of the vehicle

## Implementation Details

The Electric Vehicle Digital Twin is implemented in Python, using several scientific computing libraries:

- **NumPy**: For numerical computations and array operations
- **SciPy**: For solving differential equations (using `solve_ivp`)
- **Matplotlib**: For visualization and plotting
- **Pandas**: For data handling and export

### Battery Model Implementation

The battery model is implemented in the `SimplifiedBatteryModel` class, which provides methods to:
- Initialize a battery model with custom parameters
- Simulate battery behavior under different load conditions
- Track voltage, current, capacity, and temperature
- Provide battery state information to the EV digital twin
### Exporting Markdown to PDF

Key methods include:
- `_calculate_voltage`: Calculates battery voltage based on SOC
- `_battery_dynamics`: Defines the differential equations for SOC and temperature
- `simulate`: Simulates battery behavior with a given current profile
- `apply_constant_current`: Applies a constant current to the battery
- `apply_drive_cycle`: Applies a power-based drive cycle to the battery
- `get_state`: Returns the current battery state

### Motor Model Implementation

The motor model is implemented in the `SimplifiedPMSMMotorModel` class, which provides methods to:
- Initialize a PMSM motor model with custom parameters
- Simulate motor behavior under different load conditions
- Track torque, speed, currents, and voltages
- Provide motor state information to the EV digital twin

Key methods include:
- `_motor_dynamics`: Defines the differential equations for motor speed and currents
- `_calculate_voltages`: Calculates d-q voltages based on current state
- `_dq_to_abc`: Converts d-q currents to three-phase abc currents
- `_calculate_efficiency`: Calculates motor efficiency
- `simulate`: Simulates motor behavior with a given torque profile
- `run_speed_profile`: Runs the motor with a given speed profile
- `get_state`: Returns the current motor state

### Vehicle Physics Implementation

The vehicle physics model is implemented as part of the `ElectricVehicleDigitalTwin` class, which provides methods to:
- Initialize an EV digital twin with custom parameters
- Simulate EV behavior under different driving conditions
- Track battery and motor states
- Export simulation data for analysis

Key methods include:
- `_calculate_resistive_forces`: Calculates resistive forces acting on the vehicle
- `_speed_to_motor_rpm`: Converts vehicle speed to motor rpm
- `_torque_to_force`: Converts motor torque to tractive force
- `_calculate_power_demand`: Calculates power demand based on vehicle dynamics
- `_update_vehicle_state`: Updates vehicle state based on speed and acceleration
- `simulate`: Simulates the EV with a given speed profile
- `export_to_csv`: Exports simulation results to CSV
- `plot_results`: Plots the simulation results

## Simulation Process

The overall simulation process in the Electric Vehicle Digital Twin follows these steps:

1. **Initialization**:
   - Create battery model with specified parameters
   - Create motor model with specified parameters
   - Initialize vehicle state variables

2. **Simulation Loop**:
   - For each time step in the simulation duration:
     - Get target speed from the speed profile
     - Calculate acceleration
     - Update vehicle state
     - Calculate motor speed and torque requirements
     - Calculate power demand
     - Apply current to battery model
     - Apply torque to motor model
     - Store simulation data

3. **Results Processing**:
   - Compile simulation results into a dictionary
   - Optionally export results to CSV
   - Optionally plot results

This process is implemented in the `simulate` method of the `ElectricVehicleDigitalTwin` class:

```python
def simulate(self, speed_profile, duration, dt=1.0):
    # Reset simulation data
    self.time_data = []
    self.speed_data = []
    self.acceleration_data = []
    self.distance_data = []
    self.power_demand_data = []
    self.battery_soc_data = []
    self.battery_voltage_data = []
    self.battery_current_data = []
    self.battery_temperature_data = []
    self.motor_speed_data = []
    self.motor_torque_data = []
    self.motor_efficiency_data = []
    
    # Reset vehicle state
    self.current_speed = 0.0
    self.current_acceleration = 0.0
    self.current_distance = 0.0
    self.current_power_demand = 0.0
    
    # Create time points
    time_points = np.arange(0, duration, dt)
    
    # Previous speed for acceleration calculation
    prev_speed = 0.0
    
    # Run simulation
    for t in time_points:
        # Get target speed from profile
        target_speed = speed_profile(t)  # m/s
        
        # Calculate acceleration
        acceleration = (target_speed - prev_speed) / dt
        prev_speed = target_speed
        
        # Update vehicle state
        self._update_vehicle_state(target_speed, acceleration, dt)
        
        # Calculate motor speed and torque
        motor_speed_rpm = self._speed_to_motor_rpm(target_speed)
        
        # Calculate resistive forces
        resistive_force = self._calculate_resistive_forces(target_speed)
        
        # Calculate acceleration force
        acceleration_force = self.vehicle_mass * acceleration
        
        # Total force
        total_force = resistive_force + acceleration_force
        
        # Convert to motor torque
        motor_torque = self._force_to_torque(total_force)
        
        # Calculate power demand in kW
        power_demand = self.current_power_demand
        
        # Calculate battery current based on power demand and voltage
        battery_state = self.battery.get_state()
        battery_voltage = battery_state["voltage"]
        
        # P = V * I, so I = P / V
        # Convert power from kW to W
        if abs(battery_voltage) > 1e-6:
            battery_current = (power_demand * 1000) / battery_voltage
        else:
            battery_current = 0.0
        
        # Apply current to battery (positive current = discharge)
        battery_results = self.battery.apply_constant_current(battery_current, dt, dt)
        
        # Apply torque to motor
        def torque_profile(t_motor):
            return motor_torque
        
        motor_results = self.motor.simulate(torque_profile, dt, dt)
        
        # Store data
        self.time_data.append(t)
        self.speed_data.append(target_speed)
        self.acceleration_data.append(acceleration)
        self.distance_data.append(self.current_distance)
        self.power_demand_data.append(power_demand)
        
        # Battery data
        self.battery_soc_data.append(self.battery.current_soc)
        self.battery_voltage_data.append(self.battery.current_voltage)
        self.battery_current_data.append(battery_current)
        self.battery_temperature_data.append(self.battery.current_temperature)
        
        # Motor data
        self.motor_speed_data.append(self.motor.current_speed)
        self.motor_torque_data.append(self.motor.current_torque)
        self.motor_efficiency_data.append(self.motor.current_efficiency)
    
    # Return results
    return {
        "time": np.array(self.time_data),
        "speed": np.array(self.speed_data),
        "acceleration": np.array(self.acceleration_data),
        "distance": np.array(self.distance_data),
        "power_demand": np.array(self.power_demand_data),
        "battery_soc": np.array(self.battery_soc_data),
        "battery_voltage": np.array(self.battery_voltage_data),
        "battery_current": np.array(self.battery_current_data),
        "battery_temperature": np.array(self.battery_temperature_data),
        "motor_speed": np.array(self.motor_speed_data),
        "motor_torque": np.array(self.motor_torque_data),
        "motor_efficiency": np.array(self.motor_efficiency_data)
    }
```

## References

1. Tremblay, O., & Dessaint, L. A. (2009). Experimental validation of a battery dynamic model for EV applications. World Electric Vehicle Journal, 3(2), 289-298.

2. Mohan, N., Undeland, T. M., & Robbins, W. P. (2003). Power electronics: converters, applications, and design. John Wiley & Sons.

3. Ehsani, M., Gao, Y., & Emadi, A. (2009). Modern electric, hybrid electric, and fuel cell vehicles: fundamentals, theory, and design. CRC press.

4. Larminie, J., & Lowry, J. (2012). Electric vehicle technology explained. John Wiley & Sons.

5. Husain, I. (2011). Electric and hybrid vehicles: design fundamentals. CRC press.

6. Guzzella, L., & Sciarretta, A. (2007). Vehicle propulsion systems: introduction to modeling and optimization. Springer Science & Business Media.

7. Hendershot, J. R., & Miller, T. J. E. (2010). Design of brushless permanent-magnet machines. Motor Design Books.

8. Krishnan, R. (2017). Permanent magnet synchronous and brushless DC motor drives. CRC press.

9. Gillespie, T. D. (1992). Fundamentals of vehicle dynamics. Society of Automotive Engineers.

10. Wong, J. Y. (2008). Theory of ground vehicles. John Wiley & Sons.
